<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js - Máscara de Oclusión Real (Depth Mask)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 2px black;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
        /* Ocultamos el elemento de video que solo usamos para la textura */
        #video-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <video id="video-background" playsinline autoplay muted></video>
    <div id="info">Gradiente ultra-suave con Alpha to Coverage.</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SHADERS (con Gradiente de alta calidad 'Alpha to Coverage') ---

        const vertexShader = `
            varying vec3 vWorldNormal;
            varying vec3 vViewDirection;

            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                vViewDirection = normalize(cameraPosition - worldPosition.xyz);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        // El Fragment Shader ahora es mucho más simple. No necesita dithering manual.
        const fragmentShader = `
            varying vec3 vWorldNormal;
            varying vec3 vViewDirection;

            void main() {
                // --- Gradiente Radial Invertido ---
                // El producto punto nos da un valor cercano a 1 en el centro y 0 en los bordes.
                float dotProduct = abs(dot(normalize(vWorldNormal), normalize(vViewDirection)));

                // Calculamos el valor del gradiente. El centro será opaco y los bordes transparentes.
                float gradientValue = smoothstep(0.0, 0.6, dotProduct);

                // --- Alpha to Coverage ---
                // En lugar de descartar píxeles, simplemente pasamos el valor del gradiente al canal alfa.
                // El renderer, con 'alphaToCoverage' activado, usará el antialiasing para crear
                // una transparencia de alta calidad a nivel de sub-píxel.
                // Los valores RGB no importan porque 'colorWrite' es falso.
                gl_FragColor = vec4(0.0, 0.0, 0.0, gradientValue);
            }
        `;

        // --- CONFIGURACIÓN DE LA ESCENA ---

        let scene, camera, renderer, controls;

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 9);

            // Es importante que el antialias esté activado para que 'alphaToCoverage' funcione.
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // --- CONFIGURACIÓN DE LA CÁMARA WEB COMO FONDO ---
            try {
                const videoElement = document.getElementById('video-background');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
                videoElement.srcObject = stream;
                await videoElement.play();
                const videoTexture = new THREE.VideoTexture(videoElement);
                scene.background = videoTexture;
            } catch (err) {
                console.error("Error al acceder a la cámara:", err);
                document.getElementById('info').textContent = "Error al acceder a la cámara. Asegúrate de dar permiso.";
                scene.background = new THREE.Color(0x202020);
            }

            // --- SKYBOX (solo para reflejos) ---
            const cubeTextureLoader = new THREE.CubeTextureLoader();
            const skyboxTexture = cubeTextureLoader.load([
                'https://threejs.org/examples/textures/cube/Bridge2/px.jpg', 'https://threejs.org/examples/textures/cube/Bridge2/nx.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/py.jpg', 'https://threejs.org/examples/textures/cube/Bridge2/ny.jpg',
                'https://threejs.org/examples/textures/cube/Bridge2/pz.jpg', 'https://threejs.org/examples/textures/cube/Bridge2/nz.jpg'
            ]);

            const ambientLight = new THREE.AmbientLight(0xffffff, 1.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(2, 5, 5);
            scene.add(directionalLight);

            // --- OBJETOS EN LA ESCENA ---

            // 1. Esfera de oclusión
            const occluderGeometry = new THREE.SphereGeometry(1.5, 64, 64);
            const occluderMaterial = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                depthWrite: true,
                colorWrite: false,
                alphaToCoverage: true, // ¡La clave para el gradiente suave!
            });

            const occluderSphere = new THREE.Mesh(occluderGeometry, occluderMaterial);
            occluderSphere.renderOrder = -1;
            occluderSphere.position.y = 1;
            occluderSphere.position.z = 3;
            scene.add(occluderSphere);

            // 2. Grilla de cubos de colores 5x5
            const boxGeometry = new THREE.BoxGeometry(1, 1, 1);
            const colors = [0xff6347, 0x4682b4, 0x32cd32, 0xffd700, 0x6a5acd, 0xee82ee, 0x40e0d0];
            const spacing = 1.5;

            for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                    const material = new THREE.MeshStandardMaterial({
                        color: colors[(i * 5 + j) % colors.length],
                        metalness: 0.2,
                        roughness: 0.1,
                        envMap: skyboxTexture
                    });
                    const cube = new THREE.Mesh(boxGeometry, material);
                    cube.position.x = (i - 2) * spacing;
                    cube.position.y = (j - 2) * spacing + 1;
                    cube.position.z = -2;
                    scene.add(cube);
                }
            }
            
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        init();
        animate();

    </script>
</body>
</html>

