<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Head Tracking 3D - Test</title>
    <style>
      /* Inline estilos (antes en testhead.css) */
      html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    #app { position: fixed; inset: 0; z-index: 10; }
    #webcam { position: fixed; inset: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); z-index: 0; pointer-events: none; }
    #app > canvas, canvas { position: fixed; inset: 0; z-index: 11; pointer-events: none; }
      #hud { position: fixed; top: 10px; left: 10px; z-index: 3; color: #fff; font: 600 14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; display: flex; align-items: center; gap: 8px; }
      #status { width: 10px; height: 10px; border-radius: 50%; background: #999; display: inline-block; box-shadow: 0 0 8px rgba(255,255,255,.5); }
      #controls { position: fixed; right: 12px; top: 12px; z-index: 10; color: #fff; background: rgba(0,0,0,.45); padding: 10px; border-radius: 8px; max-width: 260px; font: 500 12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
      #controls h4 { margin: 0 0 10px 0; }
      #controls label { display:block; margin-top: 8px; }
      #controls input[type=range] { width: 100%; }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="hud"><span id="status"></span><span id="note">Cargando modelo… Concede acceso a la cámara.</span></div>
    <div id="controls">
      <h4>Face Occluder</h4>
      <label><input type="checkbox" id="toggleOcc"> Usar oclusión de rostro</label>
      <label>Scale X: <span id="scaleXValue">1.0</span></label>
      <input type="range" id="scaleX" min="0.5" max="3.0" step="0.1" value="1.0">
      <label>Scale Y: <span id="scaleYValue">1.0</span></label>
      <input type="range" id="scaleY" min="0.5" max="3.0" step="0.1" value="1.0">
      <label>Scale Z: <span id="scaleZValue">1.0</span></label>
      <input type="range" id="scaleZ" min="0.5" max="3.0" step="0.1" value="1.0">
      <label>Pos X: <span id="posXValue">0.0</span></label>
      <input type="range" id="posX" min="-2" max="2" step="0.1" value="0">
      <label>Pos Y: <span id="posYValue">0.2</span></label>
      <input type="range" id="posY" min="-2" max="2" step="0.1" value="0.2">
      <label>Pos Z: <span id="posZValue">0.0</span></label>
      <input type="range" id="posZ" min="-2" max="2" step="0.1" value="0">
    </div>

    <!-- Código JS inline (antes en testhead.js) -->
    <script type="module">
      // Usar URLs explícitas para máxima compatibilidad (sin import maps)
      import * as THREE from 'https://esm.sh/three@0.160.0';
      import Delaunator from 'https://esm.sh/delaunator@5';
      import { FBXLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/FBXLoader.js';
      import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest';

      // DOM elements
      const app = document.getElementById('app');
      const webcam = document.getElementById('webcam');
      const statusDot = document.getElementById('status');
      const note = document.getElementById('note');

      // Face mesh occluder controls
      let faceScaleX = 1.0, faceScaleY = 1.0, faceScaleZ = 1.0;
      let facePosX = 0.0, facePosY = 0.2, facePosZ = 0.0;

      // 3D setup
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.sortObjects = true;
  app.appendChild(renderer.domElement);
  Object.assign(renderer.domElement.style, { position: 'fixed', inset: '0', zIndex: '11', pointerEvents: 'none' });

      const scene = new THREE.Scene();
      scene.background = null;

      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.01, 100);
      camera.position.set(0, 0, 6);
      camera.lookAt(0, 0, 0);

      // Lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(4, 6, 8);
      scene.add(dir);

      // Face landmark mesh (depth-only occluder)
      let faceMesh = null;
      let faceMeshGeom = null;
      let facePositions = null;
      let faceTargets = null;
      let lastTriangulationFrame = -1;
      const triFrameSkip = 3;

      const ensureFaceMesh = (count) => {
        if (faceMesh) return;
        facePositions = new Float32Array(count * 3);
        faceTargets = new Float32Array(count * 3);
        faceMeshGeom = new THREE.BufferGeometry();
        faceMeshGeom.setAttribute('position', new THREE.BufferAttribute(facePositions, 3));
        const faceMat = new THREE.MeshBasicMaterial({ colorWrite: false, depthWrite: true, depthTest: true });
        faceMesh = new THREE.Mesh(faceMeshGeom, faceMat);
        faceMesh.frustumCulled = false;
        faceMesh.visible = false; // visible sólo cuando la oclusión esté activa
        faceMesh.renderOrder = -1; // primero
        scene.add(faceMesh);
      };

      // Followers (esferas)
      const followerCount = 180;
      const followers = [];
      const rand = (a, b) => a + Math.random() * (b - a);
      const DOT_COLORS = ['#00FFFF', '#C77DFF', '#3D348B', '#7209B7', '#5E2EA7', '#A45CFF', '#36E5FF', '#8A2BE2', '#B794F4'];

      const sphereColliders = [];
      const faceExclusionRadius = 1.2;
      const minGap = 0.05;

      function checkSphereCollision(x, y, z, radius) {
        const distanceFromFaceCenter = Math.sqrt(x*x + y*y + (z > 0 ? z*z : 0));
        if (z > -0.3 && distanceFromFaceCenter < faceExclusionRadius + radius) {
          return { collision: true, type: 'face' };
        }
        for (let i = 0; i < sphereColliders.length; i++) {
          const other = sphereColliders[i];
          const dx = x - other.x;
          const dy = y - other.y;
          const dz = z - other.z;
          const centerDistance = Math.sqrt(dx*dx + dy*dy + dz*dz);
          const requiredDistance = radius + other.radius + minGap;
          if (centerDistance < requiredDistance) {
            return { collision: true, type: 'sphere', distance: centerDistance, required: requiredDistance, overlap: requiredDistance - centerDistance };
          }
        }
        return { collision: false };
      }

      function findValidPosition(targetRadius, zone, maxAttempts = 200) {
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          let x, y, z;
          switch (zone) {
            case 'behind':
              x = (Math.random() - 0.5) * 4.0; y = (Math.random() - 0.5) * 4.0; z = -Math.abs(Math.random() * 3.0 + 0.3); break;
            case 'sides': {
              const isLeft = Math.random() < 0.5; const sideDistance = rand(2.0, 4.0);
              x = isLeft ? -sideDistance : sideDistance; y = (Math.random() - 0.5) * 3.0; z = (Math.random() - 0.5) * 5.0; break; }
            case 'front-corners': {
              const isLeftCorner = Math.random() < 0.5; x = isLeftCorner ? rand(-4.0, -2.0) : rand(2.0, 4.0);
              y = (Math.random() - 0.5) * 2.5; z = rand(1.0, 3.0); break; }
            case 'top':
              x = (Math.random() - 0.5) * 2.5; y = rand(2.0, 4.0); z = (Math.random() - 0.5) * 2.0; break;
          }
          const collision = checkSphereCollision(x, y, z, targetRadius);
          if (!collision.collision) return { x, y, z, success: true };
        }
        return { success: false };
      }

      let successfulPlacements = 0;
      for (let i = 0; i < followerCount && successfulPlacements < followerCount; i++) {
        let r, zone, position;
        const distribution = Math.random();
        if (distribution < 0.4) { zone = 'behind'; r = rand(0.06, 0.15); }
        else if (distribution < 0.65) { zone = 'sides'; r = rand(0.12, 0.25); }
        else if (distribution < 0.85) { zone = 'front-corners'; r = rand(0.18, 0.32); }
        else { zone = 'top'; r = rand(0.15, 0.28); }

        position = findValidPosition(r, zone);
        if (!position.success) { r *= 0.7; position = findValidPosition(r, zone); }
        if (!position.success) { r *= 0.7; position = findValidPosition(r, zone); }
        if (!position.success) continue;

        const { x, y, z } = position;
        sphereColliders.push({ x, y, z, radius: r });
        const geo = new THREE.SphereGeometry(r, 24, 24);
        const colorHex = DOT_COLORS[Math.floor(Math.random() * DOT_COLORS.length)];
        const color = new THREE.Color(colorHex);
        const emissiveColor = new THREE.Color(colorHex).multiplyScalar(0.4);
        const mat = new THREE.MeshStandardMaterial({ color, emissive: emissiveColor, roughness: 0.6, metalness: 0.1, transparent: false });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, y, z);
        const orbit = { baseRadius: Math.sqrt(x*x + y*y + z*z), theta: Math.atan2(z, x), phi: Math.acos(y / Math.sqrt(x*x + y*y + z*z)), dTheta: rand(-0.15, 0.15) * 0.25, dPhi: rand(-0.15, 0.15) * 0.25, followLerp: rand(0.02, 0.06), zMul: rand(1.3, 2.2), zBias: -rand(0.3, 1.0) };
        mesh.userData.orbit = orbit; mesh.userData.radius = r; mesh.renderOrder = 1; followers.push(mesh); scene.add(mesh);
        successfulPlacements++;
      }

      console.log(`Successfully placed ${successfulPlacements} out of ${followerCount} spheres without overlap`);

      // Head tracking state
      const headPos = new THREE.Vector3();
      const headPosSmoothed = new THREE.Vector3();
      const tmp = new THREE.Vector3();
      const mirrorVideoX = true;
      const faceColliderCenter = new THREE.Vector3();
      let faceColliderRadius = 0.9;
      const faceColliderMargin = 0.1;
      const facePlaneMargin = 0.08;
      const meshRadialScale = 1.6 * 0.93 * 0.97;
      const meshExtraPush = 0.0;
      const meshHorizontalScale = 0.9 * 0.95;

      // FBX head occluder
      const fbxLoader = new FBXLoader();
      let headOccluderRoot = null;
      let headOccluderMesh = null;
      let headOccluderLoaded = false;
      let baseOccluderWidth = 1;
      let headOccScaleSmoothed = 1;
      let headOccQuatSmoothed = new THREE.Quaternion();
      const headOccCorrection = new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.PI, Math.PI, 0));
      const occluderBackOffsetFactor = 0.3;
      const occluderSizeAdjust = 1.0;
      let occluderEnabled = false; // desactivado por defecto

      function setDepthOnlyMaterial(root) {
        root.traverse((obj) => { if (obj.isMesh) obj.material = new THREE.MeshBasicMaterial({ colorWrite: false }); });
      }

      fbxLoader.load('occluder.fbx', (obj) => {
        headOccluderMesh = obj; setDepthOnlyMaterial(headOccluderMesh);
        const box = new THREE.Box3().setFromObject(headOccluderMesh);
        const center = new THREE.Vector3(); const size = new THREE.Vector3();
        box.getCenter(center); box.getSize(size); baseOccluderWidth = Math.max(1e-3, size.x);
        headOccluderMesh.position.sub(center);
        headOccluderRoot = new THREE.Group(); headOccluderRoot.add(headOccluderMesh);
        headOccluderRoot.frustumCulled = false; headOccluderRoot.visible = false; scene.add(headOccluderRoot);
        headOccluderLoaded = true;
      }, undefined, (err) => { console.error('Error cargando occluder.fbx', err); });

      function normToNDC(x, y) {
        const cw = renderer.domElement.clientWidth; const ch = renderer.domElement.clientHeight;
        const vw = webcam.videoWidth || 1280; const vh = webcam.videoHeight || 720;
        const videoAspect = vw / vh; const canvasAspect = cw / ch;
        let xNorm = x, yNorm = y;
        if (videoAspect > canvasAspect) { const displayedWidth = ch * videoAspect; const offsetX = (displayedWidth - cw) / 2; const xDisp = x * displayedWidth - offsetX; xNorm = xDisp / cw; }
        else { const displayedHeight = cw / videoAspect; const offsetY = (displayedHeight - ch) / 2; const yDisp = y * displayedHeight - offsetY; yNorm = yDisp / ch; }
        xNorm = THREE.MathUtils.clamp(xNorm, 0, 1); yNorm = THREE.MathUtils.clamp(yNorm, 0, 1); if (mirrorVideoX) xNorm = 1 - xNorm;
        return { x: xNorm * 2 - 1, y: (1 - yNorm) * 2 - 1 };
      }
      function normToScreen(x, y) {
        const cw = renderer.domElement.clientWidth; const ch = renderer.domElement.clientHeight;
        const vw = webcam.videoWidth || 1280; const vh = webcam.videoHeight || 720;
        const videoAspect = vw / vh; const canvasAspect = cw / ch; let xNorm = x, yNorm = y;
        if (videoAspect > canvasAspect) { const displayedWidth = ch * videoAspect; const offsetX = (displayedWidth - cw) / 2; const xDisp = x * displayedWidth - offsetX; xNorm = xDisp / cw; }
        else { const displayedHeight = cw / videoAspect; const offsetY = (displayedHeight - ch) / 2; const yDisp = y * displayedHeight - offsetY; yNorm = yDisp / ch; }
        xNorm = THREE.MathUtils.clamp(xNorm, 0, 1); yNorm = THREE.MathUtils.clamp(yNorm, 0, 1); if (mirrorVideoX) xNorm = 1 - xNorm; return { x: xNorm * cw, y: yNorm * ch };
      }

      function onResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
      window.addEventListener('resize', onResize);

      // MediaPipe
      let faceLandmarker = null; let lastVideoTime = -1;
      async function initFaceLandmarker() {
        try {
          const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm');
          faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
            baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task', delegate: 'GPU' },
            outputFaceBlendshapes: false, outputFacialTransformationMatrices: false, runningMode: 'VIDEO', numFaces: 1
          });
          statusDot.style.background = '#2ecc71'; statusDot.style.boxShadow = '0 0 12px rgba(46,204,113,.9)';
          note.textContent = 'Modelo cargado. Moviendo esferas con tu cabeza.';
        } catch (err) {
          console.error(err); note.textContent = 'Error al cargar el modelo: ' + (err?.message || err);
          statusDot.style.background = '#e74c3c'; statusDot.style.boxShadow = '0 0 12px rgba(231,76,60,.9)';
        }
      }
      async function initCamera() {
        try { const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false }); webcam.srcObject = stream; await webcam.play(); }
        catch (err) { console.error('No se pudo acceder a la cámara', err); note.textContent = 'No se pudo acceder a la cámara. Revisa permisos y usa HTTPS/localhost.'; statusDot.style.background = '#e74c3c'; statusDot.style.boxShadow = '0 0 12px rgba(231,76,60,.9)'; }
      }

  // Iniciar inicializaciones en paralelo sin bloquear el render
  initCamera();
  initFaceLandmarker();

      // Render loop
      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.033);
        if (faceLandmarker && webcam.readyState >= 2) {
          const videoTime = webcam.currentTime;
          if (videoTime !== lastVideoTime) {
            lastVideoTime = videoTime;
            const res = faceLandmarker.detectForVideo(webcam, performance.now());
            if (res?.faceLandmarks?.length) {
              const landmarks = res.faceLandmarks[0];
              ensureFaceMesh(landmarks.length);
              let sx = 0, sy = 0, sz = 0; for (let i = 0; i < landmarks.length; i++) { const l = landmarks[i]; sx += l.x; sy += l.y; sz += l.z; }
              const n = landmarks.length; const cx = sx / n, cy = sy / n, cz = sz / n;
              const ndc = normToNDC(cx, cy); const p = new THREE.Vector3(ndc.x, ndc.y, 0.5).unproject(camera);
              const dirRay = p.sub(camera.position).normalize(); const targetDistance = 3.0;
              headPos.copy(camera.position).add(dirRay.multiplyScalar(targetDistance)); headPosSmoothed.lerp(headPos, 0.25);

              const zScale = 1.8; const count = landmarks.length;
              for (let i = 0; i < count; i++) { const l = landmarks[i]; const ndcP = normToNDC(l.x, l.y); const proj = new THREE.Vector3(ndcP.x, ndcP.y, 0.5).unproject(camera); const ray = proj.sub(camera.position).normalize(); const zOff = THREE.MathUtils.clamp((l.z - cz) * -zScale, -1.2, 1.2); const dist = targetDistance + zOff; const idx = i * 3; faceTargets[idx + 0] = camera.position.x + ray.x * dist; faceTargets[idx + 1] = camera.position.y + ray.y * dist; faceTargets[idx + 2] = camera.position.z + ray.z * dist; }

              if (meshRadialScale !== 1.0 || meshExtraPush !== 0.0 || meshHorizontalScale !== 1.0) {
                const cxw = headPosSmoothed.x, cyw = headPosSmoothed.y, czw = headPosSmoothed.z;
                for (let i = 0; i < count; i++) { const idx = i * 3; let x = faceTargets[idx + 0] - cxw; let y = faceTargets[idx + 1] - cyw; let z = faceTargets[idx + 2] - czw; const len = Math.hypot(x, y, z) || 1.0; x = x * meshRadialScale + (x / len) * meshExtraPush; y = y * meshRadialScale + (y / len) * meshExtraPush; z = z * meshRadialScale + (z / len) * meshExtraPush; x *= meshHorizontalScale; faceTargets[idx + 0] = cxw + x; faceTargets[idx + 1] = cyw + y; faceTargets[idx + 2] = czw + z; }
              }

              if (facePositions && faceTargets) { const lerpF = 0.35; for (let i = 0; i < facePositions.length; i++) { const cur = facePositions[i]; const to = faceTargets[i]; facePositions[i] = cur + (to - cur) * lerpF; } faceMeshGeom.attributes.position.needsUpdate = true; faceMeshGeom.computeVertexNormals(); }

              const frameNumber = Math.floor(performance.now() / (1000 / 60));
              if (frameNumber !== lastTriangulationFrame && (frameNumber % triFrameSkip === 0)) {
                lastTriangulationFrame = frameNumber;
                const pts2D = new Array(count); for (let i = 0; i < count; i++) { const l = landmarks[i]; const s = normToScreen(l.x, l.y); pts2D[i] = [s.x, s.y]; }
                const dela = Delaunator.from(pts2D); const tris = dela.triangles; const idxArr = new Uint16Array(tris); faceMeshGeom.setIndex(new THREE.BufferAttribute(idxArr, 1)); faceMeshGeom.computeVertexNormals();
              }

              // Occluder visibility controlled by checkbox
              if (faceMesh) { faceMesh.visible = occluderEnabled; faceMesh.scale.set(faceScaleX, faceScaleY, faceScaleZ); faceMesh.position.set(facePosX, facePosY, facePosZ); }

              if (occluderEnabled && headOccluderLoaded && headOccluderRoot && facePositions) {
                headOccluderRoot.visible = true; headOccluderRoot.position.copy(headPosSmoothed);
                try {
                  const countPos = faceMeshGeom.attributes.position.count;
                  if (countPos >= 3) {
                    const pick = (i) => { const idx = i * 3; return new THREE.Vector3(facePositions[idx + 0], facePositions[idx + 1], facePositions[idx + 2]); };
                    const noseIdx = Math.min(1, countPos - 1); const leftIdx = Math.min(234, countPos - 1); const rightIdx = Math.min(454, countPos - 1);
                    const noseP = pick(noseIdx); const leftP = pick(leftIdx); const rightP = pick(rightIdx);
                    const vRight = rightP.clone().sub(leftP).normalize(); const mid = leftP.clone().add(rightP).multiplyScalar(0.5); const vForward = mid.clone().sub(noseP).normalize();
                    const vUp = new THREE.Vector3().crossVectors(vForward, vRight).normalize(); const vRightOrtho = new THREE.Vector3().crossVectors(vUp, vForward).normalize();
                    const m = new THREE.Matrix4(); m.makeBasis(vRightOrtho, vUp, vForward); let q = new THREE.Quaternion().setFromRotationMatrix(m);
                    const e = new THREE.Euler().setFromQuaternion(q, 'YXZ'); if (mirrorVideoX) e.y = -e.y; e.x = -e.x; e.x *= 0.45; const qAdj = new THREE.Quaternion().setFromEuler(e, 'YXZ');
                    headOccQuatSmoothed.slerp(qAdj, 0.25); const corrected = headOccQuatSmoothed.clone().multiply(headOccCorrection); headOccluderRoot.quaternion.copy(corrected);
                    let minXw = Infinity, maxXw = -Infinity; for (let i = 0; i < faceMeshGeom.attributes.position.count; i++) { const idx = i * 3; const x = facePositions[idx + 0]; if (x < minXw) minXw = x; if (x > maxXw) maxXw = x; }
                    const faceWidthNow = Math.max(1e-3, maxXw - minXw); const forwardWorld = new THREE.Vector3(0, 0, 1).applyQuaternion(corrected).normalize(); const backOffset = -faceWidthNow * occluderBackOffsetFactor; headOccluderRoot.position.copy(headPosSmoothed).addScaledVector(forwardWorld, backOffset);
                  } else { headOccluderRoot.lookAt(camera.position); }
                } catch (e) { headOccluderRoot.lookAt(camera.position); }

                let minX = Infinity, maxX = -Infinity; for (let i = 0; i < faceMeshGeom.attributes.position.count; i++) { const idx = i * 3; const x = facePositions[idx + 0]; if (x < minX) minX = x; if (x > maxX) maxX = x; }
                const faceWidth = Math.max(1e-3, maxX - minX); const targetScale = (faceWidth / baseOccluderWidth) * occluderSizeAdjust; headOccScaleSmoothed += (targetScale - headOccScaleSmoothed) * 0.25; headOccluderRoot.scale.setScalar(headOccScaleSmoothed);
                faceColliderCenter.copy(headPosSmoothed); faceColliderRadius = (faceWidth * 0.5) * 1.08;
              }

              // Siempre mantener el collider aunque la oclusión esté OFF
              if (faceMeshGeom && facePositions) {
                let minX = Infinity, maxX = -Infinity; for (let i = 0; i < faceMeshGeom.attributes.position.count; i++) { const idx = i * 3; const x = facePositions[idx + 0]; if (x < minX) minX = x; if (x > maxX) maxX = x; }
                const faceWidthAny = Math.max(1e-3, maxX - minX); faceColliderCenter.copy(headPosSmoothed); faceColliderRadius = (faceWidthAny * 0.5) * 1.08;
              }
            } else {
              headPosSmoothed.lerp(new THREE.Vector3(0, 0, 0), 0.02);
              if (faceMesh) faceMesh.visible = false; if (headOccluderRoot) headOccluderRoot.visible = false;
            }
          }
        }

        // Seguimiento de esferas
        for (const s of followers) {
          const o = s.userData.orbit; o.theta += o.dTheta * dt; o.phi += o.dPhi * dt; const r = o.baseRadius;
          const ox = r * Math.sin(o.phi) * Math.cos(o.theta); const oy = r * Math.cos(o.phi); let oz = r * Math.sin(o.phi) * Math.sin(o.theta);
          oz = oz * o.zMul + o.zBias; tmp.set(ox, oy, oz).add(headPosSmoothed);
          const dxh = tmp.x - faceColliderCenter.x; const dyh = tmp.y - faceColliderCenter.y; const dzh = tmp.z - faceColliderCenter.z; const distHeadSq = dxh*dxh + dyh*dyh + dzh*dzh; const minHeadDist = faceColliderRadius + s.userData.radius + faceColliderMargin;
          if (distHeadSq > 0.0001) { const distHead = Math.sqrt(distHeadSq); if (distHead < minHeadDist) { const scale = (minHeadDist - distHead) / distHead; tmp.x += dxh * scale; tmp.y += dyh * scale; tmp.z += dzh * scale; } }
          const sideAllowance = Math.abs(ox) > r * 0.6; if (!sideAllowance && tmp.z > headPosSmoothed.z + facePlaneMargin) { tmp.z = headPosSmoothed.z + facePlaneMargin; }
          s.position.lerp(tmp, o.followLerp);
        }

        for (let iter = 0; iter < 3; iter++) {
          for (let i = 0; i < followers.length; i++) {
            const a = followers[i]; const ra = a.userData.radius;
            for (let j = i + 1; j < followers.length; j++) {
              const b = followers[j]; const rb = b.userData.radius; const dx = b.position.x - a.position.x; const dy = b.position.y - a.position.y; const dz = b.position.z - a.position.z; const distSq = dx*dx + dy*dy + dz*dz; const minDist = ra + rb + 0.01; if (distSq > 0) { const dist = Math.sqrt(distSq); if (dist < minDist) { const overlap = (minDist - dist); const nx = dx / dist; const ny = dy / dist; const nz = dz / dist; const stiffness = 0.5; const factor = stiffness * (1.0 - iter * 0.25); const push = overlap * 0.5 * Math.max(0.1, factor); const pushAx = -nx * push; const pushAy = -ny * push; const pushAz = -nz * push; const pushBx = nx * push; const pushBy = ny * push; const pushBz = nz * push; a.position.x = THREE.MathUtils.lerp(a.position.x, a.position.x + pushAx, 0.7); a.position.y = THREE.MathUtils.lerp(a.position.y, a.position.y + pushAy, 0.7); a.position.z = THREE.MathUtils.lerp(a.position.z, a.position.z + pushAz, 0.7); b.position.x = THREE.MathUtils.lerp(b.position.x, b.position.x + pushBx, 0.7); b.position.y = THREE.MathUtils.lerp(b.position.y, b.position.y + pushBy, 0.7); b.position.z = THREE.MathUtils.lerp(b.position.z, b.position.z + pushBz, 0.7); const faceZ = headPosSmoothed.z + facePlaneMargin; if (a.position.z > faceZ) a.position.z = faceZ; if (b.position.z > faceZ) b.position.z = faceZ; } }
            }
          }
        }

        renderer.render(scene, camera);
      }

      // Controles UI
      const scaleXSlider = document.getElementById('scaleX');
      const scaleYSlider = document.getElementById('scaleY');
      const scaleZSlider = document.getElementById('scaleZ');
      const posXSlider = document.getElementById('posX');
      const posYSlider = document.getElementById('posY');
      const posZSlider = document.getElementById('posZ');
      const scaleXValue = document.getElementById('scaleXValue');
      const scaleYValue = document.getElementById('scaleYValue');
      const scaleZValue = document.getElementById('scaleZValue');
      const posXValue = document.getElementById('posXValue');
      const posYValue = document.getElementById('posYValue');
      const posZValue = document.getElementById('posZValue');
      const toggleOcc = document.getElementById('toggleOcc');

      scaleXSlider?.addEventListener('input', (e) => { faceScaleX = parseFloat(e.target.value); if (scaleXValue) scaleXValue.textContent = faceScaleX.toFixed(1); });
      scaleYSlider?.addEventListener('input', (e) => { faceScaleY = parseFloat(e.target.value); if (scaleYValue) scaleYValue.textContent = faceScaleY.toFixed(1); });
      scaleZSlider?.addEventListener('input', (e) => { faceScaleZ = parseFloat(e.target.value); if (scaleZValue) scaleZValue.textContent = faceScaleZ.toFixed(1); });
      posXSlider?.addEventListener('input', (e) => { facePosX = parseFloat(e.target.value); if (posXValue) posXValue.textContent = facePosX.toFixed(1); });
      posYSlider?.addEventListener('input', (e) => { facePosY = parseFloat(e.target.value); if (posYValue) posYValue.textContent = facePosY.toFixed(1); });
      posZSlider?.addEventListener('input', (e) => { facePosZ = parseFloat(e.target.value); if (posZValue) posZValue.textContent = facePosZ.toFixed(1); });
      toggleOcc?.addEventListener('change', (e) => { occluderEnabled = !!e.target.checked; if (headOccluderRoot) headOccluderRoot.visible = occluderEnabled; if (faceMesh) faceMesh.visible = occluderEnabled; });

      animate();
    </script>
  </body>
</html>
